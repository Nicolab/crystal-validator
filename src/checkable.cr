module Check
  annotation Checker
  end

  # Includes `Checkable` and `CheckableStatic`.
  # It must be used in conjonction with #rules.
  macro checkable
    include Check::Checkable
    extend Check::CheckableStatic
  end

  # Generates `check` and `clean` methods for fields.
  macro rules(**fields)
    {% for field, rules in fields %}
      {% clean = rules["clean"] %}
      {% check = rules["check"] %}
      {% type = clean["type"] %}

      # Returns {{field}} with the good type and formatted if *format* is `true`.
      # The return type is a tuple with a bool as a first argument indicating
      # that the clean has been processed successfully or not and the 2nd
      # argument is the value cleaned.
      def self.clean_{{field}}(value, format = true) : Tuple(Bool, {{type}} | Nil)
        {% if to = clean["to"] %}
          # Check if the *value* has the method `{{to}}` and execute it if
          # exists to cast the value in the good type.
          if value.responds_to? {{to}}
            begin
              value = value.{{to.id}}
            rescue
              return false, nil
            end
          end
        {% end %}

        if value.is_a? {{type}} | Nil
          {% if format = clean["format"] %}
            # If *format* is true then call it to format *value*.
            if format
              begin
                return true, {{format}}.call(value)
              rescue
                return false, nil
              end
            else
              return true, value
            end
          {% else %}
            return true, value
          {% end %}
        end

        {false, nil}
      end

      # Create a new `Check::Validation` and checks {{field}}
      # For more infos check `#check_{{field}}(v : Check::Validation, value, format : Bool = true)`
      def self.check_{{field}}(*, value, format : Bool = true)
        v = Check.new_validation
        self.check_{{field}}(v, value, format)
      end

      # Cleans and check *value*.
      # If *format* is `true` it tells `#clean` to execute the `format` function
      # for this field if it has been defined with `Check#rules`.
      def self.check_{{field}}(v : Check::Validation, value, format : Bool = true)
        # Cleans and formats the *value*
        ok, value = self.clean_{{field}}(value, format)

        # If clean has encountered an error add error message and stop check here.
        if !ok
          {% msg = clean["message"] || "Wrong type" %}
          v.add_error {{field.stringify}}, {{msg}}
          return v, value
        end

        # Check against each rule provided.
        # Each rule is executed if *value* is not `nil` except for `not_empty`
        # which is executed even if the *value* is `nil`
        {% for name, args in check %}
          v.check(
            {{field.stringify}},
            {{args[0]}},
            {% if args.size <= 1 %}
              Valid.{{name.id}}? value
            {% else %}
              Valid.{{name.id}}? value, {{ args[1..-1].splat }}
            {% end %}
          ) {% if name != "not_empty" %}unless value.nil?{% end %}
        {% end %}

        {v, value}
      end
    {% end %}
  end

  # Add global check method to be used with a `Hash`.
  # The idea is to check a `Hash` against rules defined with `Check#rules` plus executing custom checkers defined with `Checker`.
  module CheckableStatic
    # Lifecycle method executed before check
    def before_check(v : Check::Validation, h : Hash, format = true)
    end

    # Lifecycle method executed after check
    def after_check(v : Check::Validation, h : Hash, format = true)
    end

    # Checks and clean the `Hash` for its keys corresponding to class field that
    # have a `#check_{{field}}` method.
    #
    # It instantiates a Check::Validation and calls all methods
    # related to rules and then methods defined with annotation `Checker`.
    #
    # Lifecycle methods `#before_check` and `#after_check` that are called respectively at the beginning and at the end of the process.
    #
    # *format* is used to tell cleaners generated by `Check#rules` to execute format method if it has been defined.
    def check(h : Hash, format = true)
      {% begin %}
      {% types = [] of Type %}
      {% fields = [] of String %}

      {% for ivar in @type.instance_vars.select { |ivar| @type.class.has_method?("check_#{ivar}") } %}
        {% types << ivar.type %}
        {% fields << ivar.name %}
      {% end %}

      # Instantiate a `Hash` with keys as `String` and values as a union of
      # all types of fields which have a method `#check_{field}`
      cleaned_h = Hash(String, {{types.join("|").id}}).new

      # Instantiate `Check::Validation`
      v = Check.new_validation

      # Call lifecycle method before check
      self.before_check v, h, format

      # Call check methods for fields for field that are present in *h* and populate
      # `cleaned_h`
      {% for field in fields %}
        if h.has_key? "{{field}}"
          v, value = self.check_{{field}}(v, h["{{field}}"], format)
          cleaned_h["{{field}}"] = value
        end
      {% end %}

      # Check methods with `Check::Checker` annotation
      {% for method in @type.class.methods.select { |method| method.annotation(Checker) } %}
        cleaned_h = {{method.name}} v, h, cleaned_h, format
      {% end %}

      # Call lifecycle method `#after_check`
      cleaned_h = self.after_check v, h, cleaned_h, format

      {v, cleaned_h}
      {% end %}
    end
  end

  # Add global check method to be used with on attributes of an instance of the class including it.
  # The idea is to check an instance of the class extending it against rules defined with `Check#rules` plus executing custom checkers defined with `Checker`.
  module Checkable
    # Lifecycle method executed before check
    def before_check(v : Check::Validation, format : Bool = true)
    end

    # Lifecycle method executed after check
    def after_check(v : Check::Validation, format : Bool = true)
    end

    # Checks the instance fields and clean them.
    #
    # It instantiates a Check::Validation and calls all methods
    # related to rules and then methods defined with annotation `Checker`.
    #
    # Lifecycle methods `#before_check` and `#after_check` that are called respectively at the beginning and at the end of the process.
    #
    # *format* is used to tell cleaners generated by `Check#rules` to execute format method if it has been defined.
    def check(format = true)
      {% begin %}
      # Instantiate `Check::Validation`
      v = Check.new_validation

      # Call lifecycle method before check
      before_check v, format

      # Check all fields that have a method `#check_{field}`
      {% for ivar in @type.instance_vars.select { |ivar| @type.class.has_method?("check_#{ivar}") } %}
        v, value = self.class.check_{{ivar.name}}(v, {{ivar.name}}, format)
        {{ivar.name}} = value
      {% end %}

      # Check methods with Check::Checker annotation
      {% for method in @type.methods.select { |method| method.annotation(Checker) } %}
        {{method.name}} v, format
      {% end %}

      # Call lifecycle method `#after_check`
      after_check v, format

      v
      {% end %}
    end
  end
end
